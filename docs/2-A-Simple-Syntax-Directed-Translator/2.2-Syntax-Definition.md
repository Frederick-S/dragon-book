# 2.2 Syntax Definition
## 2.2.1
### a
```
S
-> S S *
-> S S + S *
-> a S + S *
-> a a + S *
-> a a + a *
```

### b
```
    S
   /|\
  S S *
  | | 
  | a
 /|\
S S +
| |
a a
```

### c
$L = \lbrace\text{Reverse Polish notation expressions that use + and * as operands}\rbrace$.

## 2.2.2
### a
$L = \lbrace 0^n1^n, n\in N^+\rbrace$.

### b
$L = \lbrace\text{Polish notation expressions that use + and - as operands}\rbrace$.

### c
$L = \lbrace\text{Strings of balanced parentheses}\rbrace$.

### d
$L = \lbrace\text{String combinations of n a(s) and n b(s)}, n \in N\rbrace$.

### e
$L = \lbrace\text{Strings of regular expression}\rbrace$.

## 2.2.3
c, d, e

## 2.2.4
### a
```
list -> list list +
list -> list list -
list -> list list *
list -> list list /
list -> digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

### b
```
list -> list, id
list -> id
```

### c
```
list -> id, list
list -> id
```

### d
```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | id | (expr)
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

### e
```
expr -> expr + term | expr - term | term
term -> term * unary | term / unary | unary
unary -> + factor | - factor | factor
factor -> digit | id | (expr)
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

## 2.2.5
### a
Let's prove that if `num` is divisible by 3, then the productions `num 0` and `num num` are also divisible by 3.

We know `num 0` = `num * 2`, so if num is divisible by 3, it's obvious `num * 2` is also divisible by 3.

Now let's check another production `num num`. Suppose we have $num_1$ and $num_2$, $num_1$ has $n_1$ digits and $num_2$ has $n_2$ digits, so $num_1 \text{ } num_2$ = $num_1 * 2^{n_2} + num_2$. Since both $num_1$ and $num_2$ are divisible by 3, we can let $num_1 = 3k_1$, $num_2 = 3k_2$, so $num_1 \text{ } num_2 = 3k_12^{n_2} + 3k_2 = 3(k_12^{n_2} + k_2)$, which is also divisible by 3.

Last, let's check the base case. The base cases are `num = 11` and `num = 1001`, both are divisible by 3.

So all binary strings generated by the grammar have values divisible by 3.

### b
No, it doesn't. It's obvious that all binary strings generated by the grammar has even digits of 1. So the question is, can we find a binary number that has odd digits of 1 and is divisible by 3? Yes, we can write a simple program to find it.

```py
def digits_of_one(n):
	count = 0
	
	while n != 0:
		if n % 2 == 1:
			count += 1
		
		n = n // 2
	
	return count
	
for i in range(100):
	if i % 3 == 0 and digits_of_one(i) % 2 == 1:
		print(bin(i))
```

Output:

```
0b10101
0b101010
0b1000101
0b1010001
0b1010100
0b1010111
0b1011101
```

From 1 to 100, there are 7 numbers that can not be generated by the grammar.

## 2.2.6
```
romanNumeral -> a b c d
a -> M{1,3} | ε
b -> b1 | CD | D b1 | CM
b1 -> C{1,3} | ε
c -> c1 | XL | L c1 | XC
c1 -> X{1,3} | ε
d -> d1 | IV | V d1 | IX
d1 -> I{1,3} | ε
```